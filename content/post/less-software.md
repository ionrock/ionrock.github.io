---
date: 2024-01-30T08:33:45Z
description: ""
draft: true
title: "Less Software"
---

I'll pick on JavaScript for a moment. JS has moved so quickly through the years that it is a good case study recognizing efforts to improve. I remember when [Prototype](http://prototypejs.org/) was released, [Ajax was coined](http://adaptivepath.org/ideas/ajax-new-approach-web-applications/), and one of the great things about [jQuery](https://jquery.com) was how it helped with cross-browser incompatibility. I managed to avoid frontend work for a time, but still ran into Angular v1 and many attempts to allow writing JS in languages like Java and Python. Eventually, I started playing with React, Vue, and Elm (on a recommendation), but by this time, I can safely say my JS experience had atrophied.

What was fascinating about these changes was the amount of code that was written. Browsers became more standardized around Ecmascript and added really cool CSS features. The migration to a formal definition of JS brought about tools like Babel that back ported modern JS features for browsers that hadn't been upgraded yet. HTTP got a new version and IE disappeared in favor of Chrome based browsers. CSS became something you build and node put JS on the server. This is a massive amount of code!

Most recently, I've delved back into building things. I was excited and worried to try to learn React by way of Next.js. On the surface, things seemed really nice. But then something broke. I had to start peeling apart the layers. Was this a server or client component? Did the build break? Is my CSS getting recompiled? How do I make that HTTP request? What's wrong with my types? It was really frustrating to say the least.

The progression of these tools make sense. We used to write scripts to bundle CSS because browsers limited concurrent requests. Ajax helped reduce full page loads because the internet was much slower. JS libraries were there to create a consistent API to program against that hid the differences in browsers. It is natural that these tools and libraries continued to evolve naturally, even though many of the problems being solved were not problems anymore. The result is that when I've talked to younger engineers, the complexity of the tools is simply a part of life. This is really too bad.

For my own projects, I've said that's enough. I want less software. I don't want to build my CSS, I want less. I don't want to reproduce my data model in my server, GraphQL, and my frontend code. I want to think and write at a higher level.

Writing software is expensive. Engineers have a limited amount of code they can write every day. Code does not equate to value, but value may be an outcome of code, and it is a limited resource. The industry has made strides to improve the economics of producing code. Higher-level languages do more with less code. Frameworks can help reduce repetitive tasks and decision-making. Platforms reduce operational burdens. But what else can we do to have less software?

Python is a good example of a higher-level language. You stop thinking about memory management, pointers, and CPU features. Instead, you have high-order types, functions as objects, and a whole host of features that allow more expressiveness. It is not without its tradeoffs, though. The GIL is an obvious limitation. With more code, there is more overhead. Things get slower. But all this is just reality. When Moore's law was in full effect, we happily optimized for development speed, expecting the overhead to be a wash. We understood the tradeoffs and accepted them.

Therefore, to get less software, what tradeoffs do I need to make? In the infrastructure world, we've seen the rise of containers and k8s. Yet, there were other contenders before k8s "won" the container orchestration contest. Kubernetes promised flexibility and moved from being a solution to a framework for building solutions. Other solutions were arguably more opinionated, had less scope, or aimed for simplicity. While I think we're still learning if the flexibility tradeoff for simplicity was the right one, many people have already concluded that k8s is too complicated. New providers like [Fly.io](https://fly.io) and [Vercel](https://vercel.com) aim for simplicity over flexibility. The tradeoff they require is that your code fits in their boxes.

I believe less software is the way to build more value. But, if I'm not using the flexibility and scalability of k8s, the shadow DOM React frontend performance, or the convenience of Edge computing, the question is, what do I optimize for? In my case, I'm optimizing for understanding with less software. Here is how I'm doing it.



*The less you need to redefine your data model, the better.* The NoSQL movement had more to do with avoiding schema changes than avoiding SQL. Once you had a model in place, using it was easy enough. If you really hated SQL, ORMs were great. What was challenging was when you were changing that model. You didn't know what the right way to store data was going to be. Your language was dynamically typed, but your SQL databases didn't drum to the same beat.

I say all this because I think we've shifted back to appreciating types. The validation code that you had to write in a dynamic world is greatly reduced with types, so we'll happily suffer in the short term. The problem comes with the architecture of our systems.

We assume that a frontend that talks to a backend through a well defined API will be better, where "better" we'll define as more flexible. To achieve this separation between frontend and backend, we define types in the frontend. These types are defined according to an API, that is provided by the backend. Therefore, our separation between frontend and backend through a well defined API has cost a redefinition of our types 2-3 times. This is too expensive.

So much of programming is taking data in one format and turning it into another. I don't need to make more work for myself here. I'm going to create a data model once and do everything I can to never need to recreate that model. The implecations of this are interesting. I generate HTML on the server. The API is there to support other software, not a user interface. I can create guarantees about the data because there is one writer and one reader to the data store. Everything else is to support rendering a UI or supporting programmatic access.

The second is to optimize your data interface.

*Your database schema should be flexible, so your interface can be optimized.* When you write an application, you are responsible for telling the computer explicitly what you want to happen. Often times we don't realize where we could optimize the process. It is natural to create some database and tables and start reading and writing data. It was also natural for settlers to take an ax in the woods and chop down trees to build a house. As a programmer, you know you're going to read and write data, and yet we still define schemas, write SQL (or something similar), and convert data to and from your database to your language of choice. Can we do better?

We've sensed hints there are improvements to make. As I started writing applications again, I started down the path of integrating an auth provider. In theory, this is a great optimization. I redirect a user to a provider, they make sure this person is legit, and they send them back to me with a fancy token saying this person passed the test. This felt like a great optimization something I didn't want to write. I didn't have to add a form, work with different identity providers, save passwords, and help people reset credentials when they got screwed up. Again, it feels like less software, but it isn't.

What happened was that this auth provider, understandably, needed details to work. It needed me to configure my social login providers. I had to validate the fancy token and write my own middleware. When someone signed up I needed to add them to my own database. When I went deeper and wanted credentials for a cli app, I needed to call APIs with complex data structures to create a special token, that took a week to get working, only to realize I could only create 10 before I needed to start forking out some cash. I'm cheap, but this wasted my time and that is expensive.

The root of the problem was that it felt like an optimization, but, due to the requirements and rigor necessary to safely send the data throughout the system, it was simply moving the software. Instead, I wrote my own to do auth (using many of the same libraries as this provider I might add) with less code. What's more I also gained access to new functionality. I could send emails. I could generate my own keys for other use cases. What does this have to do with optimizing your data interface?

The benefit of auth providers hint, you're getting something convenient. The reality is you're really just moving some code around. But what if you really can get convenience that lasts? The key is to create a data interface that works at a higher level than the database itself. I'm not talking about ORMs or how you write better abstractions in your code. That has to happen no matter what. Creating a higher level interface takes away some of the challenges you always have to deal with. Frameworks have been doing it, but there are some services that also seem to provide an important benefit.

[Orb](https://withorb.com) is a good example. They offer a billing system as a service. Billing data is a well known variety and the underly data model is not terribly complicated. Orb offers some pretty slick event based billing that can be pretty challenging. On the one hand, it is challenging to scale, but more importantly, it takes a ton of gruntwork off your plate. You get a data interface around pricing, subscriptions, invoicing, etc. This isn't that hard. Create a price table and look it up when you need to charge someone, rinse and repeat as your requirements change. Even though it isn't hard, it is time consuming. You might need to make changes over time that require major changes to your system. What if you need to experiment with pricing, deprecate skus, allow revenue sharing, offer coupons/credits, bulk pricing, etc.? Whether or not Orb supports all this now, its data interface is at a higher level and that means less software.

I don't see many other companies like Orb that create a better interface around a known problem space. But, I'm working on something that aims to do just that in another common use case for applications. The goal is to create a better interface around a common requirement that lets you avoid a bunch of actual code. It doesn't move your data model around and it doesn't spread your own code across other services. Most importantly though, it promotes less software to focus on more value.
